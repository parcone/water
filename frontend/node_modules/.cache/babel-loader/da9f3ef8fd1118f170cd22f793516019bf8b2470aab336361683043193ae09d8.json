{"ast":null,"code":"class ImagePreloader {\n  constructor() {\n    this.cache = new Map();\n    this.loading = new Map();\n    this.maxCacheSize = 100;\n    this.supportsWebP = this.checkWebPSupport();\n    this.onPreviewLoad = null; // Initialize the callback\n  }\n\n  /**\r\n   * 检查浏览器是否支持WebP\r\n   * @returns {Promise<boolean>}\r\n   */\n  async checkWebPSupport() {\n    try {\n      const webP = new Image();\n      return new Promise(resolve => {\n        webP.onload = () => resolve(true);\n        webP.onerror = () => resolve(false);\n        webP.src = 'data:image/webp;base64,UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==';\n      });\n    } catch {\n      return false;\n    }\n  }\n\n  /**\r\n   * 获取最适合的图片URL\r\n   * @param {string} src - 原始图片地址\r\n   * @returns {string} 优化后的图片地址\r\n   */\n  async getOptimizedImageUrl(src) {\n    // 当前项目未生成 WebP 版本资源，直接返回原图，避免无效的 404 请求\n    return src;\n  }\n\n  /**\r\n   * 预加载单张图片\r\n   * @param {string} src - 图片地址\r\n   * @param {Object} [options] - 配置选项\r\n   * @param {boolean} [options.lowQualityPreview=true] - 是否加载低质量预览\r\n   * @returns {Promise<HTMLImageElement>}\r\n   */\n  async load(src, {\n    lowQualityPreview = true\n  } = {}) {\n    if (this.cache.has(src)) {\n      return Promise.resolve(this.cache.get(src));\n    }\n    if (this.loading.has(src)) {\n      return this.loading.get(src);\n    }\n    const optimizedSrc = await this.getOptimizedImageUrl(src);\n    const promise = new Promise((resolve, reject) => {\n      const img = new Image();\n      if (lowQualityPreview) {\n        // 先加载低质量预览图\n        const previewSrc = this.getLowQualityPreview(optimizedSrc);\n        const previewImg = new Image();\n        previewImg.src = previewSrc;\n        previewImg.onload = () => {\n          // 触发预览图加载完成回调\n          if (this.onPreviewLoad) {\n            this.onPreviewLoad(previewImg);\n          }\n        };\n      }\n      img.onload = () => {\n        this.cache.set(src, img);\n        this.loading.delete(src);\n        this.cleanup();\n        resolve(img);\n      };\n      img.onerror = () => {\n        this.loading.delete(src);\n        reject(new Error(`Failed to load image: ${src}`));\n      };\n\n      // 设置图片加载优先级\n      img.loading = 'lazy';\n      img.decoding = 'async';\n\n      // 使用优化后的URL\n      img.src = optimizedSrc;\n    });\n    this.loading.set(src, promise);\n    return promise;\n  }\n\n  /**\r\n   * 批量预加载图片\r\n   * @param {string[]} sources - 图片地址数组\r\n   * @param {Object} [options] - 配置选项\r\n   * @param {number} [options.concurrency=5] - 并发数\r\n   * @param {function} [options.onProgress] - 进度回调\r\n   * @returns {Promise<HTMLImageElement[]>}\r\n   */\n  loadMultiple(sources, {\n    concurrency = 5,\n    onProgress\n  } = {}) {\n    const total = sources.length;\n    let loaded = 0;\n    let failed = 0;\n\n    // 创建加载队列\n    const queue = sources.slice();\n    const results = new Array(total);\n    const loading = new Set();\n    return new Promise((resolve, reject) => {\n      const loadNext = () => {\n        // 如果队列为空且没有正在加载的项，完成加载\n        if (queue.length === 0 && loading.size === 0) {\n          if (failed === total) {\n            reject(new Error('All images failed to load'));\n          } else {\n            resolve(results.filter(Boolean));\n          }\n          return;\n        }\n\n        // 如果队列不为空且未达到并发限制，继续加载\n        while (queue.length > 0 && loading.size < concurrency) {\n          const index = sources.length - queue.length;\n          const src = queue.shift();\n          loading.add(src);\n          this.load(src).then(img => {\n            results[index] = img;\n            loaded++;\n            loading.delete(src);\n            if (onProgress) {\n              onProgress({\n                loaded,\n                failed,\n                total,\n                percent: (loaded + failed) / total * 100\n              });\n            }\n            loadNext();\n          }).catch(error => {\n            console.error(error);\n            failed++;\n            loading.delete(src);\n            if (onProgress) {\n              onProgress({\n                loaded,\n                failed,\n                total,\n                percent: (loaded + failed) / total * 100\n              });\n            }\n            loadNext();\n          });\n        }\n      };\n      loadNext();\n    });\n  }\n\n  /**\r\n   * 预加载图片序列\r\n   * @param {string[]} sources - 图片地址数组\r\n   * @param {Object} [options] - 配置选项\r\n   * @param {number} [options.preloadCount=3] - 预加载数量\r\n   * @param {function} [options.onProgress] - 进度回调\r\n   * @returns {Promise<void>}\r\n   */\n  loadSequence(sources, {\n    preloadCount = 3,\n    onProgress\n  } = {}) {\n    let currentIndex = 0;\n    const loadNext = async () => {\n      const endIndex = Math.min(currentIndex + preloadCount, sources.length);\n      const batch = sources.slice(currentIndex, endIndex);\n      if (batch.length === 0) return;\n      await this.loadMultiple(batch, {\n        onProgress: progress => {\n          if (onProgress) {\n            onProgress({\n              ...progress,\n              currentIndex,\n              totalImages: sources.length\n            });\n          }\n        }\n      });\n      currentIndex = endIndex;\n      if (currentIndex < sources.length) {\n        await loadNext();\n      }\n    };\n    return loadNext();\n  }\n\n  /**\r\n   * 获取低质量预览图URL\r\n   * @param {string} src - 原始图片地址\r\n   * @returns {string} 低质量预览图URL\r\n   */\n  getLowQualityPreview(src) {\n    // 这里可以根据实际需求生成缩略图URL\n    // 例如：添加查询参数来请求较小的图片\n    return `${src}?quality=10&width=50`;\n  }\n\n  /**\r\n   * 设置预览图加载完成回调\r\n   * @param {function} callback - 回调函数\r\n   */\n  setPreviewLoadCallback(callback) {\n    this.onPreviewLoad = callback;\n  }\n\n  /**\r\n   * 检查图片是否已缓存\r\n   * @param {string} src - 图片地址\r\n   * @returns {boolean}\r\n   */\n  has(src) {\n    return this.cache.has(src);\n  }\n\n  /**\r\n   * 获取缓存的图片\r\n   * @param {string} src - 图片地址\r\n   * @returns {HTMLImageElement|undefined}\r\n   */\n  get(src) {\n    return this.cache.get(src);\n  }\n\n  /**\r\n   * 清除指定图片的缓存\r\n   * @param {string} src - 图片地址\r\n   */\n  remove(src) {\n    this.cache.delete(src);\n  }\n\n  /**\r\n   * 清除所有缓存\r\n   */\n  clear() {\n    this.cache.clear();\n    this.loading.clear();\n  }\n\n  /**\r\n   * 获取缓存统计信息\r\n   * @returns {Object}\r\n   */\n  stats() {\n    return {\n      cached: this.cache.size,\n      loading: this.loading.size,\n      maxSize: this.maxCacheSize\n    };\n  }\n\n  /**\r\n   * 清理过期缓存（FIFO）\r\n   */\n  cleanup() {\n    if (this.cache.size > this.maxCacheSize) {\n      const deleteCount = this.cache.size - this.maxCacheSize;\n      const keys = Array.from(this.cache.keys());\n      keys.slice(0, deleteCount).forEach(key => this.cache.delete(key));\n    }\n  }\n}\n\n// 创建默认实例\nconst imagePreloader = new ImagePreloader();\nexport default imagePreloader;","map":{"version":3,"names":["ImagePreloader","constructor","cache","Map","loading","maxCacheSize","supportsWebP","checkWebPSupport","onPreviewLoad","webP","Image","Promise","resolve","onload","onerror","src","getOptimizedImageUrl","load","lowQualityPreview","has","get","optimizedSrc","promise","reject","img","previewSrc","getLowQualityPreview","previewImg","set","delete","cleanup","Error","decoding","loadMultiple","sources","concurrency","onProgress","total","length","loaded","failed","queue","slice","results","Array","Set","loadNext","size","filter","Boolean","index","shift","add","then","percent","catch","error","console","loadSequence","preloadCount","currentIndex","endIndex","Math","min","batch","progress","totalImages","setPreviewLoadCallback","callback","remove","clear","stats","cached","maxSize","deleteCount","keys","from","forEach","key","imagePreloader"],"sources":["D:/restore/water-melt/frontend/src/utils/preload.js"],"sourcesContent":["class ImagePreloader {\r\n  constructor() {\r\n    this.cache = new Map()\r\n    this.loading = new Map()\r\n    this.maxCacheSize = 100\r\n    this.supportsWebP = this.checkWebPSupport()\r\n    this.onPreviewLoad = null // Initialize the callback\r\n  }\r\n\r\n  /**\r\n   * 检查浏览器是否支持WebP\r\n   * @returns {Promise<boolean>}\r\n   */\r\n  async checkWebPSupport() {\r\n    try {\r\n      const webP = new Image()\r\n      return new Promise((resolve) => {\r\n        webP.onload = () => resolve(true)\r\n        webP.onerror = () => resolve(false)\r\n        webP.src = 'data:image/webp;base64,UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA=='\r\n      })\r\n    } catch {\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 获取最适合的图片URL\r\n   * @param {string} src - 原始图片地址\r\n   * @returns {string} 优化后的图片地址\r\n   */\r\n  async getOptimizedImageUrl(src) {\r\n    // 当前项目未生成 WebP 版本资源，直接返回原图，避免无效的 404 请求\r\n    return src\r\n  }\r\n\r\n  /**\r\n   * 预加载单张图片\r\n   * @param {string} src - 图片地址\r\n   * @param {Object} [options] - 配置选项\r\n   * @param {boolean} [options.lowQualityPreview=true] - 是否加载低质量预览\r\n   * @returns {Promise<HTMLImageElement>}\r\n   */\r\n  async load(src, { lowQualityPreview = true } = {}) {\r\n    if (this.cache.has(src)) {\r\n      return Promise.resolve(this.cache.get(src))\r\n    }\r\n\r\n    if (this.loading.has(src)) {\r\n      return this.loading.get(src)\r\n    }\r\n\r\n    const optimizedSrc = await this.getOptimizedImageUrl(src)\r\n    \r\n    const promise = new Promise((resolve, reject) => {\r\n      const img = new Image()\r\n      \r\n      if (lowQualityPreview) {\r\n        // 先加载低质量预览图\r\n        const previewSrc = this.getLowQualityPreview(optimizedSrc)\r\n        const previewImg = new Image()\r\n        previewImg.src = previewSrc\r\n        previewImg.onload = () => {\r\n          // 触发预览图加载完成回调\r\n          if (this.onPreviewLoad) {\r\n            this.onPreviewLoad(previewImg)\r\n          }\r\n        }\r\n      }\r\n\r\n      img.onload = () => {\r\n        this.cache.set(src, img)\r\n        this.loading.delete(src)\r\n        this.cleanup()\r\n        resolve(img)\r\n      }\r\n\r\n      img.onerror = () => {\r\n        this.loading.delete(src)\r\n        reject(new Error(`Failed to load image: ${src}`))\r\n      }\r\n\r\n      // 设置图片加载优先级\r\n      img.loading = 'lazy'\r\n      img.decoding = 'async'\r\n      \r\n      // 使用优化后的URL\r\n      img.src = optimizedSrc\r\n    })\r\n\r\n    this.loading.set(src, promise)\r\n    return promise\r\n  }\r\n\r\n  /**\r\n   * 批量预加载图片\r\n   * @param {string[]} sources - 图片地址数组\r\n   * @param {Object} [options] - 配置选项\r\n   * @param {number} [options.concurrency=5] - 并发数\r\n   * @param {function} [options.onProgress] - 进度回调\r\n   * @returns {Promise<HTMLImageElement[]>}\r\n   */\r\n  loadMultiple(sources, { concurrency = 5, onProgress } = {}) {\r\n    const total = sources.length\r\n    let loaded = 0\r\n    let failed = 0\r\n\r\n    // 创建加载队列\r\n    const queue = sources.slice()\r\n    const results = new Array(total)\r\n    const loading = new Set()\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const loadNext = () => {\r\n        // 如果队列为空且没有正在加载的项，完成加载\r\n        if (queue.length === 0 && loading.size === 0) {\r\n          if (failed === total) {\r\n            reject(new Error('All images failed to load'))\r\n          } else {\r\n            resolve(results.filter(Boolean))\r\n          }\r\n          return\r\n        }\r\n\r\n        // 如果队列不为空且未达到并发限制，继续加载\r\n        while (queue.length > 0 && loading.size < concurrency) {\r\n          const index = sources.length - queue.length\r\n          const src = queue.shift()\r\n          loading.add(src)\r\n\r\n          this.load(src)\r\n            .then(img => {\r\n              results[index] = img\r\n              loaded++\r\n              loading.delete(src)\r\n\r\n              if (onProgress) {\r\n                onProgress({\r\n                  loaded,\r\n                  failed,\r\n                  total,\r\n                  percent: ((loaded + failed) / total) * 100\r\n                })\r\n              }\r\n\r\n              loadNext()\r\n            })\r\n            .catch(error => {\r\n              console.error(error)\r\n              failed++\r\n              loading.delete(src)\r\n\r\n              if (onProgress) {\r\n                onProgress({\r\n                  loaded,\r\n                  failed,\r\n                  total,\r\n                  percent: ((loaded + failed) / total) * 100\r\n                })\r\n              }\r\n\r\n              loadNext()\r\n            })\r\n        }\r\n      }\r\n\r\n      loadNext()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * 预加载图片序列\r\n   * @param {string[]} sources - 图片地址数组\r\n   * @param {Object} [options] - 配置选项\r\n   * @param {number} [options.preloadCount=3] - 预加载数量\r\n   * @param {function} [options.onProgress] - 进度回调\r\n   * @returns {Promise<void>}\r\n   */\r\n  loadSequence(sources, { preloadCount = 3, onProgress } = {}) {\r\n    let currentIndex = 0\r\n\r\n    const loadNext = async () => {\r\n      const endIndex = Math.min(currentIndex + preloadCount, sources.length)\r\n      const batch = sources.slice(currentIndex, endIndex)\r\n\r\n      if (batch.length === 0) return\r\n\r\n      await this.loadMultiple(batch, {\r\n        onProgress: progress => {\r\n          if (onProgress) {\r\n            onProgress({\r\n              ...progress,\r\n              currentIndex,\r\n              totalImages: sources.length\r\n            })\r\n          }\r\n        }\r\n      })\r\n\r\n      currentIndex = endIndex\r\n      if (currentIndex < sources.length) {\r\n        await loadNext()\r\n      }\r\n    }\r\n\r\n    return loadNext()\r\n  }\r\n\r\n  /**\r\n   * 获取低质量预览图URL\r\n   * @param {string} src - 原始图片地址\r\n   * @returns {string} 低质量预览图URL\r\n   */\r\n  getLowQualityPreview(src) {\r\n    // 这里可以根据实际需求生成缩略图URL\r\n    // 例如：添加查询参数来请求较小的图片\r\n    return `${src}?quality=10&width=50`\r\n  }\r\n\r\n  /**\r\n   * 设置预览图加载完成回调\r\n   * @param {function} callback - 回调函数\r\n   */\r\n  setPreviewLoadCallback(callback) {\r\n    this.onPreviewLoad = callback\r\n  }\r\n\r\n  /**\r\n   * 检查图片是否已缓存\r\n   * @param {string} src - 图片地址\r\n   * @returns {boolean}\r\n   */\r\n  has(src) {\r\n    return this.cache.has(src)\r\n  }\r\n\r\n  /**\r\n   * 获取缓存的图片\r\n   * @param {string} src - 图片地址\r\n   * @returns {HTMLImageElement|undefined}\r\n   */\r\n  get(src) {\r\n    return this.cache.get(src)\r\n  }\r\n\r\n  /**\r\n   * 清除指定图片的缓存\r\n   * @param {string} src - 图片地址\r\n   */\r\n  remove(src) {\r\n    this.cache.delete(src)\r\n  }\r\n\r\n  /**\r\n   * 清除所有缓存\r\n   */\r\n  clear() {\r\n    this.cache.clear()\r\n    this.loading.clear()\r\n  }\r\n\r\n  /**\r\n   * 获取缓存统计信息\r\n   * @returns {Object}\r\n   */\r\n  stats() {\r\n    return {\r\n      cached: this.cache.size,\r\n      loading: this.loading.size,\r\n      maxSize: this.maxCacheSize\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 清理过期缓存（FIFO）\r\n   */\r\n  cleanup() {\r\n    if (this.cache.size > this.maxCacheSize) {\r\n      const deleteCount = this.cache.size - this.maxCacheSize\r\n      const keys = Array.from(this.cache.keys())\r\n      keys.slice(0, deleteCount).forEach(key => this.cache.delete(key))\r\n    }\r\n  }\r\n}\r\n\r\n// 创建默认实例\r\nconst imagePreloader = new ImagePreloader()\r\n\r\nexport default imagePreloader "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}