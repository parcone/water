{"ast":null,"code":"import axios from 'axios';\nimport { ElMessage } from 'element-plus';\nimport store from '@/store';\nimport cache from './cache';\n\n// 默认配置\nconst DEFAULT_CONFIG = {\n  retries: 3,\n  retryDelay: 1000,\n  retryStatusCodes: [408, 429, 500, 502, 503, 504],\n  cacheExpiration: 5 * 60 * 1000,\n  // 5分钟\n  backgroundRefresh: true\n};\n\n// 创建axios实例\nconst service = axios.create({\n  baseURL: process.env.VUE_APP_BASE_API || '/api',\n  timeout: 15000\n});\n\n/**\r\n * 延迟执行\r\n * @param {number} ms 延迟时间（毫秒）\r\n */\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n/**\r\n * 生成缓存键\r\n * @param {Object} config 请求配置\r\n * @returns {string} 缓存键\r\n */\nconst generateCacheKey = config => {\n  const {\n    url,\n    params,\n    data,\n    method\n  } = config;\n  return `request_${method}_${url}_${JSON.stringify(params || {})}_${JSON.stringify(data || {})}`;\n};\n\n/**\r\n * 检查是否应该重试请求\r\n * @param {Error} error 错误对象\r\n * @param {Object} config 请求配置\r\n * @returns {boolean}\r\n */\nconst shouldRetry = (error, config) => {\n  const {\n    retries = DEFAULT_CONFIG.retries,\n    retryStatusCodes = DEFAULT_CONFIG.retryStatusCodes\n  } = config;\n  const currentRetry = config.__retryCount || 0;\n  if (currentRetry >= retries) {\n    return false;\n  }\n  if (error.response) {\n    return retryStatusCodes.includes(error.response.status);\n  }\n  return error.code === 'ECONNABORTED' || !error.response;\n};\n\n// 请求拦截器\nservice.interceptors.request.use(async config => {\n  // 从缓存中获取token\n  const token = store.getters['auth/token'];\n  if (token) {\n    config.headers['Authorization'] = `Bearer ${token}`;\n  }\n\n  // 处理请求缓存\n  if (config.cache) {\n    const cacheKey = generateCacheKey(config);\n    const cachedData = cache.get(cacheKey);\n    if (cachedData) {\n      // 如果启用后台刷新，异步更新缓存\n      if (config.backgroundRefresh !== false && DEFAULT_CONFIG.backgroundRefresh) {\n        setTimeout(() => {\n          service({\n            ...config,\n            cache: false,\n            __isBackgroundRefresh: true\n          }).then(response => {\n            cache.set(cacheKey, response.data, config.cacheExpiration || DEFAULT_CONFIG.cacheExpiration);\n          });\n        }, 0);\n      }\n\n      // 返回缓存数据\n      config.cancelToken = new axios.CancelToken(cancel => {\n        cancel('Request canceled due to cache hit');\n      });\n      return {\n        ...config,\n        __fromCache: true,\n        __cacheData: cachedData\n      };\n    }\n    config.__cacheKey = cacheKey;\n  }\n  return config;\n}, error => {\n  console.error('Request error:', error);\n  return Promise.reject(error);\n});\n\n// 响应拦截器\nservice.interceptors.response.use(response => {\n  // 处理从缓存返回的数据\n  if (response.config.__fromCache) {\n    return response.config.__cacheData;\n  }\n  const {\n    data\n  } = response;\n\n  // 处理业务错误\n  if (data.code && data.code !== 200) {\n    // 如果是后台刷新，不显示错误消息\n    if (!response.config.__isBackgroundRefresh) {\n      ElMessage.error(data.message || '请求失败');\n    }\n    return Promise.reject(new Error(data.message || '请求失败'));\n  }\n\n  // 缓存响应数据\n  if (response.config.cache && response.config.__cacheKey) {\n    cache.set(response.config.__cacheKey, data, response.config.cacheExpiration || DEFAULT_CONFIG.cacheExpiration);\n  }\n  return data;\n}, async error => {\n  // 处理缓存导致的请求取消\n  if (axios.isCancel(error)) {\n    return Promise.resolve(error.message);\n  }\n  const config = error.config;\n\n  // 处理重试逻辑\n  if (shouldRetry(error, config)) {\n    config.__retryCount = (config.__retryCount || 0) + 1;\n    const retryDelay = config.retryDelay || DEFAULT_CONFIG.retryDelay;\n    await delay(retryDelay * config.__retryCount);\n    return service(config);\n  }\n\n  // 处理网络错误\n  let message = '网络错误';\n  if (error.response) {\n    switch (error.response.status) {\n      case 401:\n        message = '未授权，请登录';\n        store.dispatch('auth/logout');\n        break;\n      case 403:\n        message = '拒绝访问';\n        break;\n      case 404:\n        message = '请求地址不存在';\n        break;\n      case 429:\n        message = '请求过于频繁，请稍后再试';\n        break;\n      case 500:\n        message = '服务器内部错误';\n        break;\n      default:\n        message = error.response.data.message || `请求失败 ${error.response.status}`;\n    }\n  } else if (error.request) {\n    message = '服务器无响应';\n  } else {\n    message = error.message;\n  }\n\n  // 如果是后台刷新，不显示错误消息\n  if (!config.__isBackgroundRefresh) {\n    ElMessage.error(message);\n  }\n  return Promise.reject(error);\n});\n\n/**\r\n * 请求方法封装\r\n * @param {Object} config - axios配置\r\n * @param {boolean} [config.cache=false] - 是否启用缓存\r\n * @param {number} [config.cacheExpiration] - 缓存过期时间（毫秒）\r\n * @param {boolean} [config.backgroundRefresh] - 是否启用后台刷新\r\n * @param {number} [config.retries] - 重试次数\r\n * @param {number} [config.retryDelay] - 重试延迟（毫秒）\r\n * @param {number[]} [config.retryStatusCodes] - 需要重试的状态码\r\n * @returns {Promise}\r\n */\nconst request = async config => {\n  try {\n    const response = await service(config);\n    return response;\n  } catch (error) {\n    return Promise.reject(error);\n  }\n};\n\n// 请求方法别名\nrequest.get = (url, config = {}) => request({\n  ...config,\n  method: 'get',\n  url\n});\nrequest.post = (url, data, config = {}) => request({\n  ...config,\n  method: 'post',\n  url,\n  data\n});\nrequest.put = (url, data, config = {}) => request({\n  ...config,\n  method: 'put',\n  url,\n  data\n});\nrequest.delete = (url, config = {}) => request({\n  ...config,\n  method: 'delete',\n  url\n});\n\n// 批量请求\nrequest.all = axios.all;\nrequest.spread = axios.spread;\nexport default request;","map":{"version":3,"names":["axios","ElMessage","store","cache","DEFAULT_CONFIG","retries","retryDelay","retryStatusCodes","cacheExpiration","backgroundRefresh","service","create","baseURL","process","env","VUE_APP_BASE_API","timeout","delay","ms","Promise","resolve","setTimeout","generateCacheKey","config","url","params","data","method","JSON","stringify","shouldRetry","error","currentRetry","__retryCount","response","includes","status","code","interceptors","request","use","token","getters","headers","cacheKey","cachedData","get","__isBackgroundRefresh","then","set","cancelToken","CancelToken","cancel","__fromCache","__cacheData","__cacheKey","console","reject","message","Error","isCancel","dispatch","post","put","delete","all","spread"],"sources":["D:/restore/water-melt/frontend/src/utils/request.js"],"sourcesContent":["import axios from 'axios'\r\nimport { ElMessage } from 'element-plus'\r\nimport store from '@/store'\r\nimport cache from './cache'\r\n\r\n// 默认配置\r\nconst DEFAULT_CONFIG = {\r\n  retries: 3,\r\n  retryDelay: 1000,\r\n  retryStatusCodes: [408, 429, 500, 502, 503, 504],\r\n  cacheExpiration: 5 * 60 * 1000, // 5分钟\r\n  backgroundRefresh: true\r\n}\r\n\r\n// 创建axios实例\r\nconst service = axios.create({\r\n  baseURL: process.env.VUE_APP_BASE_API || '/api',\r\n  timeout: 15000\r\n})\r\n\r\n/**\r\n * 延迟执行\r\n * @param {number} ms 延迟时间（毫秒）\r\n */\r\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms))\r\n\r\n/**\r\n * 生成缓存键\r\n * @param {Object} config 请求配置\r\n * @returns {string} 缓存键\r\n */\r\nconst generateCacheKey = (config) => {\r\n  const { url, params, data, method } = config\r\n  return `request_${method}_${url}_${JSON.stringify(params || {})}_${JSON.stringify(data || {})}`\r\n}\r\n\r\n/**\r\n * 检查是否应该重试请求\r\n * @param {Error} error 错误对象\r\n * @param {Object} config 请求配置\r\n * @returns {boolean}\r\n */\r\nconst shouldRetry = (error, config) => {\r\n  const { retries = DEFAULT_CONFIG.retries, retryStatusCodes = DEFAULT_CONFIG.retryStatusCodes } = config\r\n  const currentRetry = config.__retryCount || 0\r\n  \r\n  if (currentRetry >= retries) {\r\n    return false\r\n  }\r\n\r\n  if (error.response) {\r\n    return retryStatusCodes.includes(error.response.status)\r\n  }\r\n\r\n  return error.code === 'ECONNABORTED' || !error.response\r\n}\r\n\r\n// 请求拦截器\r\nservice.interceptors.request.use(\r\n  async config => {\r\n    // 从缓存中获取token\r\n    const token = store.getters['auth/token']\r\n    if (token) {\r\n      config.headers['Authorization'] = `Bearer ${token}`\r\n    }\r\n\r\n    // 处理请求缓存\r\n    if (config.cache) {\r\n      const cacheKey = generateCacheKey(config)\r\n      const cachedData = cache.get(cacheKey)\r\n\r\n      if (cachedData) {\r\n        // 如果启用后台刷新，异步更新缓存\r\n        if (config.backgroundRefresh !== false && DEFAULT_CONFIG.backgroundRefresh) {\r\n          setTimeout(() => {\r\n            service({\r\n              ...config,\r\n              cache: false,\r\n              __isBackgroundRefresh: true\r\n            }).then(response => {\r\n              cache.set(cacheKey, response.data, config.cacheExpiration || DEFAULT_CONFIG.cacheExpiration)\r\n            })\r\n          }, 0)\r\n        }\r\n\r\n        // 返回缓存数据\r\n        config.cancelToken = new axios.CancelToken(cancel => {\r\n          cancel('Request canceled due to cache hit')\r\n        })\r\n        return {\r\n          ...config,\r\n          __fromCache: true,\r\n          __cacheData: cachedData\r\n        }\r\n      }\r\n\r\n      config.__cacheKey = cacheKey\r\n    }\r\n\r\n    return config\r\n  },\r\n  error => {\r\n    console.error('Request error:', error)\r\n    return Promise.reject(error)\r\n  }\r\n)\r\n\r\n// 响应拦截器\r\nservice.interceptors.response.use(\r\n  response => {\r\n    // 处理从缓存返回的数据\r\n    if (response.config.__fromCache) {\r\n      return response.config.__cacheData\r\n    }\r\n\r\n    const { data } = response\r\n\r\n    // 处理业务错误\r\n    if (data.code && data.code !== 200) {\r\n      // 如果是后台刷新，不显示错误消息\r\n      if (!response.config.__isBackgroundRefresh) {\r\n        ElMessage.error(data.message || '请求失败')\r\n      }\r\n      return Promise.reject(new Error(data.message || '请求失败'))\r\n    }\r\n\r\n    // 缓存响应数据\r\n    if (response.config.cache && response.config.__cacheKey) {\r\n      cache.set(\r\n        response.config.__cacheKey,\r\n        data,\r\n        response.config.cacheExpiration || DEFAULT_CONFIG.cacheExpiration\r\n      )\r\n    }\r\n\r\n    return data\r\n  },\r\n  async error => {\r\n    // 处理缓存导致的请求取消\r\n    if (axios.isCancel(error)) {\r\n      return Promise.resolve(error.message)\r\n    }\r\n\r\n    const config = error.config\r\n\r\n    // 处理重试逻辑\r\n    if (shouldRetry(error, config)) {\r\n      config.__retryCount = (config.__retryCount || 0) + 1\r\n      const retryDelay = config.retryDelay || DEFAULT_CONFIG.retryDelay\r\n      await delay(retryDelay * config.__retryCount)\r\n      return service(config)\r\n    }\r\n\r\n    // 处理网络错误\r\n    let message = '网络错误'\r\n    if (error.response) {\r\n      switch (error.response.status) {\r\n        case 401:\r\n          message = '未授权，请登录'\r\n          store.dispatch('auth/logout')\r\n          break\r\n        case 403:\r\n          message = '拒绝访问'\r\n          break\r\n        case 404:\r\n          message = '请求地址不存在'\r\n          break\r\n        case 429:\r\n          message = '请求过于频繁，请稍后再试'\r\n          break\r\n        case 500:\r\n          message = '服务器内部错误'\r\n          break\r\n        default:\r\n          message = error.response.data.message || `请求失败 ${error.response.status}`\r\n      }\r\n    } else if (error.request) {\r\n      message = '服务器无响应'\r\n    } else {\r\n      message = error.message\r\n    }\r\n\r\n    // 如果是后台刷新，不显示错误消息\r\n    if (!config.__isBackgroundRefresh) {\r\n      ElMessage.error(message)\r\n    }\r\n    \r\n    return Promise.reject(error)\r\n  }\r\n)\r\n\r\n/**\r\n * 请求方法封装\r\n * @param {Object} config - axios配置\r\n * @param {boolean} [config.cache=false] - 是否启用缓存\r\n * @param {number} [config.cacheExpiration] - 缓存过期时间（毫秒）\r\n * @param {boolean} [config.backgroundRefresh] - 是否启用后台刷新\r\n * @param {number} [config.retries] - 重试次数\r\n * @param {number} [config.retryDelay] - 重试延迟（毫秒）\r\n * @param {number[]} [config.retryStatusCodes] - 需要重试的状态码\r\n * @returns {Promise}\r\n */\r\nconst request = async (config) => {\r\n  try {\r\n    const response = await service(config)\r\n    return response\r\n  } catch (error) {\r\n    return Promise.reject(error)\r\n  }\r\n}\r\n\r\n// 请求方法别名\r\nrequest.get = (url, config = {}) => request({ ...config, method: 'get', url })\r\nrequest.post = (url, data, config = {}) => request({ ...config, method: 'post', url, data })\r\nrequest.put = (url, data, config = {}) => request({ ...config, method: 'put', url, data })\r\nrequest.delete = (url, config = {}) => request({ ...config, method: 'delete', url })\r\n\r\n// 批量请求\r\nrequest.all = axios.all\r\nrequest.spread = axios.spread\r\n\r\nexport default request "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}