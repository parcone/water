{"ast":null,"code":"class ImagePreloader {\n  constructor() {\n    this.cache = new Map();\n    this.loading = new Map();\n    this.maxCacheSize = 100; // 最大缓存数量\n  }\n\n  /**\r\n   * 预加载单张图片\r\n   * @param {string} src - 图片地址\r\n   * @returns {Promise<HTMLImageElement>}\r\n   */\n  load(src) {\n    // 如果已经缓存，直接返回\n    if (this.cache.has(src)) {\n      return Promise.resolve(this.cache.get(src));\n    }\n\n    // 如果正在加载，返回已有的promise\n    if (this.loading.has(src)) {\n      return this.loading.get(src);\n    }\n\n    // 创建新的加载promise\n    const promise = new Promise((resolve, reject) => {\n      const img = new Image();\n      img.onload = () => {\n        this.cache.set(src, img);\n        this.loading.delete(src);\n        this.cleanup();\n        resolve(img);\n      };\n      img.onerror = () => {\n        this.loading.delete(src);\n        reject(new Error(`Failed to load image: ${src}`));\n      };\n      img.src = src;\n    });\n    this.loading.set(src, promise);\n    return promise;\n  }\n\n  /**\r\n   * 批量预加载图片\r\n   * @param {string[]} sources - 图片地址数组\r\n   * @param {Object} [options] - 配置选项\r\n   * @param {number} [options.concurrency=5] - 并发数\r\n   * @param {function} [options.onProgress] - 进度回调\r\n   * @returns {Promise<HTMLImageElement[]>}\r\n   */\n  loadMultiple(sources, {\n    concurrency = 5,\n    onProgress\n  } = {}) {\n    const total = sources.length;\n    let loaded = 0;\n    let failed = 0;\n\n    // 创建加载队列\n    const queue = sources.slice();\n    const results = new Array(total);\n    const loading = new Set();\n    return new Promise((resolve, reject) => {\n      const loadNext = () => {\n        // 如果队列为空且没有正在加载的项，完成加载\n        if (queue.length === 0 && loading.size === 0) {\n          if (failed === total) {\n            reject(new Error('All images failed to load'));\n          } else {\n            resolve(results.filter(Boolean));\n          }\n          return;\n        }\n\n        // 如果队列不为空且未达到并发限制，继续加载\n        while (queue.length > 0 && loading.size < concurrency) {\n          const index = sources.length - queue.length;\n          const src = queue.shift();\n          loading.add(src);\n          this.load(src).then(img => {\n            results[index] = img;\n            loaded++;\n            loading.delete(src);\n            if (onProgress) {\n              onProgress({\n                loaded,\n                failed,\n                total,\n                percent: (loaded + failed) / total * 100\n              });\n            }\n            loadNext();\n          }).catch(error => {\n            console.error(error);\n            failed++;\n            loading.delete(src);\n            if (onProgress) {\n              onProgress({\n                loaded,\n                failed,\n                total,\n                percent: (loaded + failed) / total * 100\n              });\n            }\n            loadNext();\n          });\n        }\n      };\n      loadNext();\n    });\n  }\n\n  /**\r\n   * 预加载图片序列\r\n   * @param {string[]} sources - 图片地址数组\r\n   * @param {Object} [options] - 配置选项\r\n   * @param {number} [options.preloadCount=3] - 预加载数量\r\n   * @param {function} [options.onProgress] - 进度回调\r\n   * @returns {Promise<void>}\r\n   */\n  loadSequence(sources, {\n    preloadCount = 3,\n    onProgress\n  } = {}) {\n    let currentIndex = 0;\n    const loadNext = async () => {\n      const endIndex = Math.min(currentIndex + preloadCount, sources.length);\n      const batch = sources.slice(currentIndex, endIndex);\n      if (batch.length === 0) return;\n      await this.loadMultiple(batch, {\n        onProgress: progress => {\n          if (onProgress) {\n            onProgress({\n              ...progress,\n              currentIndex,\n              totalImages: sources.length\n            });\n          }\n        }\n      });\n      currentIndex = endIndex;\n      if (currentIndex < sources.length) {\n        await loadNext();\n      }\n    };\n    return loadNext();\n  }\n\n  /**\r\n   * 检查图片是否已缓存\r\n   * @param {string} src - 图片地址\r\n   * @returns {boolean}\r\n   */\n  has(src) {\n    return this.cache.has(src);\n  }\n\n  /**\r\n   * 获取缓存的图片\r\n   * @param {string} src - 图片地址\r\n   * @returns {HTMLImageElement|undefined}\r\n   */\n  get(src) {\n    return this.cache.get(src);\n  }\n\n  /**\r\n   * 清除指定图片的缓存\r\n   * @param {string} src - 图片地址\r\n   */\n  remove(src) {\n    this.cache.delete(src);\n  }\n\n  /**\r\n   * 清除所有缓存\r\n   */\n  clear() {\n    this.cache.clear();\n    this.loading.clear();\n  }\n\n  /**\r\n   * 获取缓存统计信息\r\n   * @returns {Object}\r\n   */\n  stats() {\n    return {\n      cached: this.cache.size,\n      loading: this.loading.size,\n      maxSize: this.maxCacheSize\n    };\n  }\n\n  /**\r\n   * 清理过期缓存（FIFO）\r\n   */\n  cleanup() {\n    if (this.cache.size > this.maxCacheSize) {\n      const deleteCount = this.cache.size - this.maxCacheSize;\n      const keys = Array.from(this.cache.keys());\n      keys.slice(0, deleteCount).forEach(key => this.cache.delete(key));\n    }\n  }\n}\n\n// 创建默认实例\nconst preloader = new ImagePreloader();\nexport default preloader;","map":{"version":3,"names":["ImagePreloader","constructor","cache","Map","loading","maxCacheSize","load","src","has","Promise","resolve","get","promise","reject","img","Image","onload","set","delete","cleanup","onerror","Error","loadMultiple","sources","concurrency","onProgress","total","length","loaded","failed","queue","slice","results","Array","Set","loadNext","size","filter","Boolean","index","shift","add","then","percent","catch","error","console","loadSequence","preloadCount","currentIndex","endIndex","Math","min","batch","progress","totalImages","remove","clear","stats","cached","maxSize","deleteCount","keys","from","forEach","key","preloader"],"sources":["D:/restore/water-melt/frontend/src/utils/preload.js"],"sourcesContent":["class ImagePreloader {\r\n  constructor() {\r\n    this.cache = new Map()\r\n    this.loading = new Map()\r\n    this.maxCacheSize = 100 // 最大缓存数量\r\n  }\r\n\r\n  /**\r\n   * 预加载单张图片\r\n   * @param {string} src - 图片地址\r\n   * @returns {Promise<HTMLImageElement>}\r\n   */\r\n  load(src) {\r\n    // 如果已经缓存，直接返回\r\n    if (this.cache.has(src)) {\r\n      return Promise.resolve(this.cache.get(src))\r\n    }\r\n\r\n    // 如果正在加载，返回已有的promise\r\n    if (this.loading.has(src)) {\r\n      return this.loading.get(src)\r\n    }\r\n\r\n    // 创建新的加载promise\r\n    const promise = new Promise((resolve, reject) => {\r\n      const img = new Image()\r\n      \r\n      img.onload = () => {\r\n        this.cache.set(src, img)\r\n        this.loading.delete(src)\r\n        this.cleanup()\r\n        resolve(img)\r\n      }\r\n\r\n      img.onerror = () => {\r\n        this.loading.delete(src)\r\n        reject(new Error(`Failed to load image: ${src}`))\r\n      }\r\n\r\n      img.src = src\r\n    })\r\n\r\n    this.loading.set(src, promise)\r\n    return promise\r\n  }\r\n\r\n  /**\r\n   * 批量预加载图片\r\n   * @param {string[]} sources - 图片地址数组\r\n   * @param {Object} [options] - 配置选项\r\n   * @param {number} [options.concurrency=5] - 并发数\r\n   * @param {function} [options.onProgress] - 进度回调\r\n   * @returns {Promise<HTMLImageElement[]>}\r\n   */\r\n  loadMultiple(sources, { concurrency = 5, onProgress } = {}) {\r\n    const total = sources.length\r\n    let loaded = 0\r\n    let failed = 0\r\n\r\n    // 创建加载队列\r\n    const queue = sources.slice()\r\n    const results = new Array(total)\r\n    const loading = new Set()\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const loadNext = () => {\r\n        // 如果队列为空且没有正在加载的项，完成加载\r\n        if (queue.length === 0 && loading.size === 0) {\r\n          if (failed === total) {\r\n            reject(new Error('All images failed to load'))\r\n          } else {\r\n            resolve(results.filter(Boolean))\r\n          }\r\n          return\r\n        }\r\n\r\n        // 如果队列不为空且未达到并发限制，继续加载\r\n        while (queue.length > 0 && loading.size < concurrency) {\r\n          const index = sources.length - queue.length\r\n          const src = queue.shift()\r\n          loading.add(src)\r\n\r\n          this.load(src)\r\n            .then(img => {\r\n              results[index] = img\r\n              loaded++\r\n              loading.delete(src)\r\n\r\n              if (onProgress) {\r\n                onProgress({\r\n                  loaded,\r\n                  failed,\r\n                  total,\r\n                  percent: ((loaded + failed) / total) * 100\r\n                })\r\n              }\r\n\r\n              loadNext()\r\n            })\r\n            .catch(error => {\r\n              console.error(error)\r\n              failed++\r\n              loading.delete(src)\r\n\r\n              if (onProgress) {\r\n                onProgress({\r\n                  loaded,\r\n                  failed,\r\n                  total,\r\n                  percent: ((loaded + failed) / total) * 100\r\n                })\r\n              }\r\n\r\n              loadNext()\r\n            })\r\n        }\r\n      }\r\n\r\n      loadNext()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * 预加载图片序列\r\n   * @param {string[]} sources - 图片地址数组\r\n   * @param {Object} [options] - 配置选项\r\n   * @param {number} [options.preloadCount=3] - 预加载数量\r\n   * @param {function} [options.onProgress] - 进度回调\r\n   * @returns {Promise<void>}\r\n   */\r\n  loadSequence(sources, { preloadCount = 3, onProgress } = {}) {\r\n    let currentIndex = 0\r\n\r\n    const loadNext = async () => {\r\n      const endIndex = Math.min(currentIndex + preloadCount, sources.length)\r\n      const batch = sources.slice(currentIndex, endIndex)\r\n\r\n      if (batch.length === 0) return\r\n\r\n      await this.loadMultiple(batch, {\r\n        onProgress: progress => {\r\n          if (onProgress) {\r\n            onProgress({\r\n              ...progress,\r\n              currentIndex,\r\n              totalImages: sources.length\r\n            })\r\n          }\r\n        }\r\n      })\r\n\r\n      currentIndex = endIndex\r\n      if (currentIndex < sources.length) {\r\n        await loadNext()\r\n      }\r\n    }\r\n\r\n    return loadNext()\r\n  }\r\n\r\n  /**\r\n   * 检查图片是否已缓存\r\n   * @param {string} src - 图片地址\r\n   * @returns {boolean}\r\n   */\r\n  has(src) {\r\n    return this.cache.has(src)\r\n  }\r\n\r\n  /**\r\n   * 获取缓存的图片\r\n   * @param {string} src - 图片地址\r\n   * @returns {HTMLImageElement|undefined}\r\n   */\r\n  get(src) {\r\n    return this.cache.get(src)\r\n  }\r\n\r\n  /**\r\n   * 清除指定图片的缓存\r\n   * @param {string} src - 图片地址\r\n   */\r\n  remove(src) {\r\n    this.cache.delete(src)\r\n  }\r\n\r\n  /**\r\n   * 清除所有缓存\r\n   */\r\n  clear() {\r\n    this.cache.clear()\r\n    this.loading.clear()\r\n  }\r\n\r\n  /**\r\n   * 获取缓存统计信息\r\n   * @returns {Object}\r\n   */\r\n  stats() {\r\n    return {\r\n      cached: this.cache.size,\r\n      loading: this.loading.size,\r\n      maxSize: this.maxCacheSize\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 清理过期缓存（FIFO）\r\n   */\r\n  cleanup() {\r\n    if (this.cache.size > this.maxCacheSize) {\r\n      const deleteCount = this.cache.size - this.maxCacheSize\r\n      const keys = Array.from(this.cache.keys())\r\n      keys.slice(0, deleteCount).forEach(key => this.cache.delete(key))\r\n    }\r\n  }\r\n}\r\n\r\n// 创建默认实例\r\nconst preloader = new ImagePreloader()\r\n\r\nexport default preloader "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}